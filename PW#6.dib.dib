#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №6. Изучение производительности потоко-безопасных очередей.

**Цель:** Определить лучшую потоко-безопасную коллекцию для выполнения интенсивной обработки входящих сообщений.

**Результаты:** После выполнения работы Вы сможете:
1. Назвать оптимальную коллекцию для обработки большого количества сообщений.
2. Изучите примтив синхронизации Условная переманная.


**Материалы для самостоятельного изучения**.
1. [Потоко-безопасные коллекции](https://learn.microsoft.com/en-us/dotnet/standard/collections/thread-safe/)
2. Условные переменные Глава 5 п.5.1. книги Г. Эндрюс Основы многопоточного, параллельного и распределенного программирования
3. [Одна из реализаций условных переменных на .Net](https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.manualresetevent?view=net-8.0)

## Задание.
Исслдеовать производительность BlockingCollection и ConcurrentQueue в сравнении с непотокоабезопасной очередью.

Для каждой потоко-безопасной очереди необходимо реализовать 2 потока: один записывает объект в очередь, а другой - читает объект из очереди.
Для непотокобезопасной очереди реализовать два цикла - записи миллиона объектов в очередь и чтение миллиона объектов из очереди.

Необходимо определить два промежутка времени:
- время за которое поток или цикл обработает миллион объектов
- время, необходимое на запись и чтение миллиона объектов из очреди.

Сделать десять замеров по каждой коллекции. Все замеры показать на графике.

Записать в ноутбуке вывод - какая и потоко-безопасных коллекций эффективнее. И выразить в процентах - скорость самой быстрой поток-безопасной коллекции по сравнению с обычной очредью.

**Указание**.
1. Необходимо исключить из замеров время, необходимое для запуска и остановки потоков, то есть посчитать чистое время, необходимое для обработки объектов.
Для этого следует использовать условные события, которые позволят убедиться, что оба потока запустились и готовы читать и писать объекты и только потом запускать таймер.
2. Для итогового вывода сравнивать усредненные значения.

#!markdown

// здесь писать код

#!markdown

#!csharp

#r "nuget:ScottPlot, 5.0.36"

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using ScottPlot;

static double TestBlockingCollection(int itemCount)
{
    var collection = new BlockingCollection<int>(itemCount);
    var readyToStart = new ManualResetEvent(false);
    var readyToEnd = new ManualResetEvent(false);

    var producer = new Thread(() =>
    {
        readyToStart.WaitOne();
        for (int i = 0; i < itemCount; i++)
        {
            collection.Add(i);
        }
        collection.CompleteAdding();
        readyToEnd.Set();
    });

    var consumer = new Thread(() =>
    {
        readyToStart.WaitOne();
        while (!collection.IsCompleted)
        {
            collection.TryTake(out _);
        }
        readyToEnd.Set();
    });

    producer.Start();
    consumer.Start();

    var stopwatch = Stopwatch.StartNew();
    readyToStart.Set();
    readyToEnd.WaitOne();
    stopwatch.Stop();

    return stopwatch.Elapsed.TotalMilliseconds;
}

static double TestConcurrentQueue(int itemCount)
{
    var queue = new ConcurrentQueue<int>();
    var readyToStart = new ManualResetEvent(false);
    var readyToEnd = new ManualResetEvent(false);

    var producer = new Thread(() =>
    {
        readyToStart.WaitOne();
        for (int i = 0; i < itemCount; i++)
        {
            queue.Enqueue(i);
        }
        readyToEnd.Set();
    });

    var consumer = new Thread(() =>
    {
        readyToStart.WaitOne();
        for (int i = 0; i < itemCount; i++)
        {
            while (!queue.TryDequeue(out _)) ;
        }
        readyToEnd.Set();
    });

    producer.Start();
    consumer.Start();

    var stopwatch = Stopwatch.StartNew();
    readyToStart.Set();
    readyToEnd.WaitOne();
    stopwatch.Stop();

    return stopwatch.Elapsed.TotalMilliseconds;
}

static double TestUnsafeQueue(int itemCount)
{
    var queue = new Queue<int>();
    var stopwatch = Stopwatch.StartNew();

    for (int i = 0; i < itemCount; i++)
    {
        queue.Enqueue(i);
    }

    for (int i = 0; i < itemCount; i++)
    {
        queue.Dequeue();
    }

    stopwatch.Stop();
    return stopwatch.Elapsed.TotalMilliseconds;
}

#!markdown

#!csharp

const int itemCount = 1000000;
const int iterations = 10;

var blockingCollectionTimes = new List<double>();
var concurrentQueueTimes = new List<double>();
var unsafeQueue = new List<double>();

for (int i = 0; i < iterations; i++)
{
    blockingCollectionTimes.Add(TestBlockingCollection(itemCount));
    concurrentQueueTimes.Add(TestConcurrentQueue(itemCount));
    unsafeQueue.Add(TestUnsafeQueue(itemCount));
}

var plt = new ScottPlot.Plot();
plt.Add.Scatter(
    Enumerable.Range(1, iterations).Select(x => (double)x).ToArray(), 
    blockingCollectionTimes.ToArray()
);
plt.Add.Scatter(
    Enumerable.Range(1, iterations).Select(x => (double)x).ToArray(), 
    concurrentQueueTimes.ToArray()
);
plt.Add.Scatter(
    Enumerable.Range(1, iterations).Select(x => (double)x).ToArray(), 
    unsafeQueue.ToArray()
);
plt.Title("Сравнение производительности очередей");
plt.XLabel("Итерации");
plt.YLabel("Время (ms)");

var avgBlockingCollection = blockingCollectionTimes.Average();
var avgConcurrentQueue = concurrentQueueTimes.Average();
var avgUnsafeQueue = unsafeQueue.Average();

Console.WriteLine($"Среднее время BlockingCollection: {avgBlockingCollection} ms");
Console.WriteLine($"Среднее время ConcurrentQueue: {avgConcurrentQueue} ms");
Console.WriteLine($"Среднее время непотокобезопасной очереди: {avgUnsafeQueue} ms");

plt

#!markdown

## Вывод

Самая быстрая потокобезопасная коллекциия - `ConcurrentQueue`

Среднее время `BlockingCollection`: 433.11 ms \
Среднее время `ConcurrentQueue`: 18.95 ms \
Среднее время непотокобезопасной очереди: 18.72 ms

Выходит, что непотокобезопасная очередь в среднем быстрее самой быстрой потокобезопасной очереди
